[PLATFORMS]
ALL


[PERMUTATIONS]
SHADING_QUALITY=SHADING_QUALITY_NORMAL // The deferred renderer only supports NORMAL shading quality
BLEND_MODE=BLEND_MODE_OPAQUE // At the lightning stage, the blend mode is always set to OPAQUE

CAMERA_MODE
VERTEX_SHADER_RENDER_TARGET_ARRAY_INDEX


[RENDERSTATE]
DepthTest = false
DepthTestFunc = CompareFunc_Less
DepthWrite = false
CullMode = CullMode_None


[VERTEXSHADER]
#include <Shaders/Pipeline/FullscreenTriangleVertexShader.h>


[GEOMETRYSHADER]
#include <Shaders/Pipeline/FullscreenTriangleStereoGeometryShader.h>


[PIXELSHADER]
#include <Shaders/Pipeline/FullscreenTriangleInterpolator.h>
static const float Epsilon = 0.0001f;

#define USE_MATERIAL_EMISSIVE
#define USE_MATERIAL_OCCLUSION
#define USE_TWO_SIDED_LIGHTING
#define USE_DECALS
#define USE_FOG

#include <Shaders/Pipeline/FullscreenTriangleInterpolator.h>
#include <Shaders/Common/Utils.h>
#include <Shaders/Common/Lighting.h>

Texture2D AlbedoTexture;
Texture2D NormalTexture;
Texture2D MaterialTexture;
Texture2D VelocityTexture;

RWTexture2D<float4> Output;

struct PS_GLOBALS
{
  PS_IN Input;
};

static PS_GLOBALS G;

// ----- Material --------------------------------

float3 GetNormal()
{
  return NormalTexture[G.Input.Position.xy].xyz;
}

float GetMetallic()
{
  return MaterialTexture[G.Input.Position.xy].r;
}

float3 GetDiffuseColor()
{
  return AlbedoTexture[G.Input.Position.xy].rgb;
}

float GetRoughness()
{
  return MaterialTexture[G.Input.Position.xy].g;
}

float3 GetEmissiveColor()
{
  float4 color = AlbedoTexture[G.Input.Position.xy];
  return color.rgb * color.a;
}

float GetOcclusion()
{
  return MaterialTexture[G.Input.Position.xy].b;
}

float GetCavity()
{
  return MaterialTexture[G.Input.Position.xy].a;
}

float2 GetVelocity()
{
  return VelocityTexture[G.Input.Position.xy].xy;
}

// TODO: Another G-Buffer map to store this?
void GetSpecularParams(
  out float clearcoat,
  out float clearcoatRoughness,
  out float anisotropic,
  out float anisotropicRotation,
  out float sheen,
  out float sheenTintFactor
) {
  clearcoat = 0;
  clearcoatRoughness = 0;
  anisotropic = 0;
  anisotropicRotation = 0;
  sheen = 0;
  sheenTintFactor = 0;
}

ezMaterialData FillMaterialData()
{
  ezMaterialData matData;

  matData.worldPosition = SampleScenePosition(G.Input.Position.xy);
  matData.worldNormal = GetNormal();
  matData.vertexNormal = float3(0, 0, 1);
  matData.emissiveColor = GetEmissiveColor();
  matData.diffuseColor = GetDiffuseColor();
  matData.refractionColor = float4(0, 0, 0, 1);
  matData.roughness = GetRoughness();
  matData.perceptualRoughness = PerceptualRoughnessFromRoughness(matData.roughness);
  matData.metalness = GetMetallic();
  matData.occlusion = GetOcclusion();
  matData.opacity = 1.0f;
  matData.cavity = GetCavity();
  matData.velocity = GetVelocity();

  matData.specularColor = lerp(0.04f, matData.diffuseColor, matData.metalness);
  matData.diffuseColor = lerp(matData.diffuseColor, 0.0f, matData.metalness);

  GetSpecularParams(
    matData.clearcoat,
    matData.clearcoatRoughness,
    matData.anisotropic,
    matData.anisotropicRotation,
    matData.sheen,
    matData.sheenTintFactor
  );

  matData.subsurfaceColor = 0.0;
  matData.subsurfaceScatterPower = 9.0;
  matData.subsurfaceShadowFalloff = 0.0;

  return matData;
}

// ---------------------------------------------------------

float4 main(PS_IN Input) : SV_Target
{
#if CAMERA_MODE == CAMERA_MODE_STEREO
  s_ActiveCameraEyeIndex = Input.RenderTargetArrayIndex;
#endif

  G.Input = Input;

  float depth = SampleSceneDepth(Input.Position.xy);
  float3 screenPos = float3(Input.Position.xy, depth);

  ezMaterialData matData = FillMaterialData();

  ezPerClusterData clusterData = GetClusterData(screenPos);
  uint gameObjectId = unpack_float16_to_uint32(NormalTexture[Input.Position.xy].w);

#if defined(USE_DECALS)
  ApplyDecals(matData, clusterData, gameObjectId);
#endif

  AccumulatedLight light = CalculateLighting(matData, clusterData, screenPos, true);

  float3 litColor = light.diffuseLight + light.specularLight;
  litColor += matData.emissiveColor;
  litColor *= matData.cavity;

  litColor = ApplyFog(litColor, matData.worldPosition);

  return float4(litColor, matData.opacity);
}
